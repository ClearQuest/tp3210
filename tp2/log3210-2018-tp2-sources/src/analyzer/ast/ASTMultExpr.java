package analyzer.ast;/* Generated By:JJTree: Do not edit this line. ASTMultExpr.java */

import java.util.ArrayList;
import java.util.Vector; // PLB

public class ASTMultExpr extends SimpleNode {
  public ASTMultExpr(int id) {
    super(id);
  }
  public ASTMultExpr(ASTMultExpr mExpr){super(mExpr.getId());}

  public ASTMultExpr(Parser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(ParserVisitor visitor, Object data) {
    return visitor.visit(this, data);
  }

 /* public ArrayList<String> reduce(){
      int val = 1;
      String[] identifiers = new String[12];
      for (int  i = 0 ; i<this.jjtGetNumChildren(); i++) {
          if (this.isStringInt(jjtGetChild(i).reduce()[i])){
                val *=Integer.parseInt(jjtGetChild(i).reduce()[i]);
          }
          else
    identifiers.add
}
      return val;
    }*/

    public ArrayList<String> reduce() {
        int val = 1;
        //ArrayList<String> identifiersArray = new ArrayList<>();
        int countMinus = 0;

        String idMultipliers = "";
        for (int i = 0; i < this.jjtGetNumChildren(); i++) {
            // Node currChild = jjtGetChild(i);
            if (this.jjtGetChild(i) instanceof ASTUnaryOpExpr) {
                ASTUnaryOpExpr tempNode = (ASTUnaryOpExpr) this.jjtGetChild(i);

                ArrayList<String> currArray = tempNode.reduce();

                for (int j = 0; j < currArray.size(); j++) {
                    String current = currArray.get(j);
                    if (this.isStringInt(current)) {
                        val *= Integer.parseInt(current);
                    } else {
                        if (current.charAt(0) == '-') {
                            countMinus++; // remind val may be neg
                            current.substring(1);
                        }
                        else if (!current.equals("")) {
                            idMultipliers += current;
                            idMultipliers += "*";
                            //identifiersArray.add(current);
                            //identifiersArray.add("*");
                        }
                    }
                }
            }
        }
        if (idMultipliers.length()>=1 && idMultipliers.charAt(idMultipliers.length() - 1) == ('*')) {
            idMultipliers = idMultipliers.substring(0, idMultipliers.length() - 1);
        }
        /*if (identifiersArray.size() >= 1 && identifiersArray.get(identifiersArray.size() - 1).equals("*")) {
            identifiersArray.remove(identifiersArray.size() - 1);
        }*/

        if (val < 0) {
            countMinus++;
            val *= -1;
        }
        ArrayList<String> s = new ArrayList<>();



        if(val!=0){
            //add negation
            if(countMinus%2 != 0) {
                if((val == 1 && idMultipliers.length() == 0)|| val != 1)
                    val *=-1;
                else if(idMultipliers.length()>0){
                    idMultipliers = "-" + idMultipliers;
                }
            }
            // add val
            if ((val == 1 && idMultipliers.length() == 0)|| val != 1) {
                s.add(Integer.toString(val));
            }
            //add mult operator
            if(val !=1 && idMultipliers.length() > 0)
                s.add("*");
            //add identifiers
            s.add(idMultipliers);
        }

        // 0
        else{
            s.add("0");
        }
        return s;

        /*String s = "";

        if (val != 0 ) {
            if (countMinus % 2 != 0)
                s += ("-");
            if ((val == 1 && idMultipliers.length() == 0)|| val != 1)//want to print value if its 1 and no ids or if it aint 1
                s += Integer.toString(val);
            if(val !=1 && idMultipliers.length()>0)
                s+="*";
            s += idMultipliers;
        }


        String finalS = s;
        return new ArrayList<String>() {{
            add(finalS);
        }};*/


    }

    // PLB
  private Vector<String> m_ops = new Vector<>();
  public void addOp(String o) { m_ops.add(o); }
  public Vector getOps() { return m_ops; }
}
